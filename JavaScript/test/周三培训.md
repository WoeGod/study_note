# for、forEach、for...in、for...of
# for

 缺点：写法繁琐，代码可读性不强

```javascript
lists = ['apple','banana','pear','watermelon','pineapple']

for (let i = 0; i < arr.length; i++){
  console.log(arr[i]);
}

```

# forEach

优点：语法简洁
缺点：不能终止或者跳过(其它几种循环都可以)

```javascript
lists = ['apple','banana','pear','watermelon','pineapple']

lists.forEach(list => {
  // if(list === 1){
  //   continue  // 报错：SyntaxError: Illegal continue statement: no surrounding iteration statement
  //                使用 break 则报错：Illegal break statement
  // }
  console.log(list);
})
```

# for...in

>`for...in` 语句用于对数组或者对象的属性进行循环操作，循环中的代码每执行一次，就会对数组的元素或者对象的属性进行一次操作，因此大多数的时候`for...in`用来遍历对象，遍历数组建议用`for`循环。

语法：

```javascript
for(变量 in 对象)
{
    在此执行代码
 }
```

>“变量”用来指定变量，指定的变量可以是数组元素，也可以是对象的属性。`for...in`的`key`是`String`类型，而非数字，它包含当前属性的名称或当前数组元素的索引。

【注】：`in`是`JavaScript`中的一个操作符，用来判断某个属性是否属于某个对象，判断的属性可以是对象自身的属性，也可以使通过`prototype`继承的属性。

## for...in 遍历数组

```javascript
lists = ['apple','banana','pear','watermelon','pineapple']

for (let index in lists){
  console.log(index);  // 0,1,2,3,4   
  console.log(typeof(index));   // string  string  string  string  string
  console.log(lists[index]);  // apple banana pear watermelon pineapple
}
```

## for...in 遍历对象

```javascript
obj = {
  name : "wu",
  age: 18,
  address: 'beijing'
}

for (let index in obj){
  console.log(index);  // name,age,address
  console.log(obj[index]);  // wu,18,beijing
}
```

【注】 需要注意的一点是`for...in`会遍历对象的属性，包括它自身的属性以及从prototype那继承来的属性。

```JavaScript
obj = {
  name : "wu",
  age: 18,
  address: 'beijing'
}

Object.prototype.number="2000";  //为obj原型添加一个number属性

for (let index in obj){
  console.log(obj[index]);  // wu,18,beijing,2000
}
```

为什么控制台将number也输出了呢？

>因为`number`属性是obj原型新添加的属性，而`for-in`会将该对象的属性全部遍历，其中就包括从原型继承的属性，因此`obj`继承了number属性，所以也输出了`number`属性的值。很多初学者常常忽略这个问题，这也导致许多`bug`的出现。

那么该如何避免这种问题呢？这时候`hasOwnProperty()`方法就派上用场了。

>`hasOwnProperty`函数用于指示一个对象自身(不包括原型链)是否具有指定名称的属性。如果有，返回`true`，否则返回`false`
>
>该方法属于`Object`对象，由于所有的对象都"继承"了`Object`的对象实例，因此几乎所有的实例对象都可以使用该方法

下面展示一下`hasOwnProperty()`方法的用法。

```javascript
obj = {
  name : "wu",
  age: 18,
  address: 'beijing'
}

Object.prototype.number="2000";  //为obj原型添加一个number属性

for (let index in obj){
  if(!obj.hasOwnProperty(index)){
    continue;
  }
  console.log(obj[index]);  // wu,18,beijing 
}
```

此时，`for...in`遍历的只有`obj`对象自身的属性，遍历数组同理

# for...of

>`for...of`语句在可迭代对象（包括 `Array`，`Map`，`Set`，`String`，`TypedArray`，`arguments` 对象等等）上创建一个迭代循环，调用自定义迭代钩子，并为每个不同属性的值执行语句

`for...of`循环不会循环对象的key，只会循环出数组的value，因此`for...of`不能循环遍历**普通对象**,对普通对象的属性遍历推荐使用`for...in`

语法：

```javascript
for (variable of iterable) {
    //statements
}
```

## 迭代`Array`

```javascript
let iterable = [10, 20, 30];

for (let value of iterable) {
    value += 1;
    console.log(value);
}
// 11
// 21
// 31
```

# 为什么使用v-for时必须添加唯一的key?

v-for中的key

使用`v-for`更新已渲染的元素列表时,默认用`就地复用`策略;列表数据修改的时候,他会根据key值去判断某个值是否修改,如果修改,则重新渲染这一项,否则复用之前的元素;
我们在使用的使用经常会使用`index`(即数组的下标)来作为`key`,但其实这是不推荐的一种使用方法;

举个例子

```javascript
const list = [
    {
        id: 1,
        name: 'test1',
    },
    {
        id: 2,
        name: 'test2',
    },
    {
        id: 3,
        name: 'test3',
    },
]
```

```javascript
<div v-for="(item, index) in list" :key="index" >{{item.name}}</div>
```

上面这种是我们做项目中常用到的一种场景,因为不加key,vue现在直接报错,所以我使用index作为key;下面列举两种常见的数据更新情况

### 1.在最后一条数据后再加一条数据

```javascript
const list = [
    {
        id: 1,
        name: 'test1',
    },
    {
        id: 2,
        name: 'test2',
    },
    {
        id: 3,
        name: 'test3',
    },
    {
        id: 4,
        name: '我是在最后添加的一条数据',
    },
]
```

此时前三条数据直接复用之前的,新渲染最后一条数据,此时用`index`作为`key`,没有任何问题;

### 2.在中间插入一条数据

```js
const list = [
    {
        id: 1,
        name: 'test1',
    },
    {
        id: 4,
        name: '我是插队的那条数据',
    }
    {
        id: 2,
        name: 'test2',
    },
    {
        id: 3,
        name: 'test3',
    },
]
```

此时更新渲染数据,通过`index`定义的`key`去进行前后数据的对比,发现

```js
之前的数据                         之后的数据

key: 0  index: 0 name: test1     key: 0  index: 0 name: test1
key: 1  index: 1 name: test2     key: 1  index: 1 name: 我是插队的那条数据
key: 2  index: 2 name: test3     key: 2  index: 2 name: test2
                                 key: 3  index: 3 name: test3
```

通过上面清晰的对比,发现除了第一个数据可以复用之前的之外,另外三条数据都需要重新渲染;

是不是很惊奇,我明明只是插入了一条数据,怎么三条数据都要重新渲染?而我想要的只是新增的那一条数据新渲染出来就行了

最好的办法是使用数组中不会变化的那一项作为`key`值,对应到项目中,即每条数据都有一个唯一的`id`,来标识这条数据的唯一性;使用`id`作为`key`值,我们再来对比一下向中间插入一条数据,此时会怎么去渲染

```js
之前的数据                              之后的数据

key: 1  id: 1 index: 0 name: test1     key: 1  id: 1 index: 0  name: test1
key: 2  id: 2 index: 1 name: test2     key: 4  id: 4 index: 1  name: 我是插队的那条数据
key: 3  id: 3 index: 2 name: test3     key: 2  id: 2 index: 2  name: test2
                                       key: 3  id: 3 index: 3  name: test3
```

现在对比发现只有一条数据变化了,就是`id`为4的那条数据,因此只要新渲染这一条数据就可以了,其他都是就复用之前的;

同理在react中使用map渲染列表时,也是必须加key,且推荐做法也是使用`id`,也是这个原因;

其实,真正的原因并不是vue和react怎么怎么,而是因为Virtual DOM 使用Diff算法实现的原因,

> 下面大致从虚拟DOM的Diff算法实现的角度去解释一下

vue和react的虚拟DOM的Diff算法大致相同，其核心是基于两个简单的假设：

1.  两个相同的组件产生类似的DOM结构，不同的组件产生不同的DOM结构。
2.  同一层级的一组节点，他们可以通过唯一的id进行区分。基于以上这两点假设，使得虚拟DOM的Diff算法的复杂度从O(n^3)降到了O(n)。

引用[React’s diff algorithm](https://calendar.perfplanet.com/2013/diff/ "Permanent Link to React’s diff algorithm")中的例子:

![diff1.jpg](https://user-gold-cdn.xitu.io/2018/6/15/16401a8ca6bea0ca?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

当某一层有很多相同的节点时，也就是列表节点时，Diff算法的更新过程默认情况下也是遵循以上原则。
比如一下这个情况：

![diff2.jpg](https://user-gold-cdn.xitu.io/2018/6/15/16401a8ca6f8c764?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

我们希望可以在B和C之间加一个F，Diff算法默认执行起来是这样的：

![diff3.jpg](https://user-gold-cdn.xitu.io/2018/6/15/16401a8ca73549bb?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

即把C更新成F，D更新成C，E更新成D，最后再插入E，是不是很没有效率？

所以我们需要使用key来给每个节点做一个唯一标识，Diff算法就可以正确的识别此节点，找到正确的位置区插入新的节点。

![diff4.jpg](https://user-gold-cdn.xitu.io/2018/6/15/16401a8ca6d7e50c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

所以一句话，key的作用主要是为了高效的更新虚拟DOM。另外vue中在使用相同标签名元素的过渡切换时，也会使用到key属性，其目的也是为了让vue可以区分它们，否则vue只会替换其内部属性而不会触发过渡效果。



**文章引用自：[https://juejin.im/post/6844903577215827982](https://juejin.im/post/6844903577215827982)**

